\documentclass[11pt,svgnames,smaller,aspectratio=169,italian]{beamer}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage[italian]{babel}
\usepackage{tikz-cd,amsmath}

\usetheme{UniPi}

%-------------------TABLE------------------------------
\usepackage{siunitx} %tabelle valore S
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}

% ------------------ CHANGE FROM HERE ------------------
\title{Crittografia a chiave pubblica: uno sguardo alle vulnerabilità \\ di RSA e Diffie-Hellman}
\author{Leonardo Alfreducci}
\institute[Università di Pisa]{Università di Pisa\\Dipartimento di Informatica}
\date{Pisa, 7 ottobre 2022}
% extra can be used for thesis supervisors and similar
\extra{Relatori\\Dott. Gaspare Ferraro\\Prof.ssa Anna Bernasconi}
% ------------------ END CHANGE ------------------

\usepackage{transparent}
\mode<presentation>

\begin{document}

\begin{frame} 
	\titlepage
\end{frame}
\logo{\transparent{0.2}\includegraphics[height=2cm]{images/cherubino}}



% ------------------ CHANGE FROM HERE ------------------
\begin{frame}{Indice}
	\tableofcontents
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduzione}
\begin{frame}
	\sectionpage
	\centering
\end{frame}

\begin{frame}{Introduzione}
	\begin{itemize}
		\item Una grandissima quantità di informazioni viaggia attraverso la rete: è dunque di fondamentale importanza proteggere i dati che vengono scambiati.
		\item Si passeranno in rassegna i due protocolli più usati per lo scambio di chiave: RSA e Diffie-Hellman, quest'ultimo analizzato su campo primo e su curve ellittiche.
		\item Lo scopo della tesi è quello di andare al di là di una trattazione teorica di questi due protocolli, concentrandosi piuttosto sull'aspetto pratico.
	\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{RSA}
\begin{frame}
	\sectionpage
	\centering
\end{frame}

\begin{frame}{RSA: la teoria dietro al protocollo}
	\begin{itemize}
		\item È un cifrario asimmetrico. Sono dunque presenti due coppie di chiavi:
		\begin{itemize}
			\item $(e, n)$ utilizzata per cifrare (\emph{chiave pubblica});
			\item $(d, n)$ utilizzata per decifrare (\emph{chiave privata}).
		\end{itemize}
		\item Si scelgono due numeri primi $p$ e $q$.
		\item Si calcola $n = p \cdot q$ e $\phi(n) = (p - 1) \cdot (q - 1)$.
		\item Si sceglie $e < \phi(n)$ tale che $gcd(e, n) = 1$.
		\item Si calcola $d = e^{-1} \mod \phi(n)$.
		\item Tutti i passi descritti possono essere svolti in tempo polinomiale.
	\end{itemize}
\end{frame}

\begin{frame}{RSA: cifratura e decifrazione}
	\begin{itemize}
		\item Per cifrare un messaggio $m$ è sufficiente calcolare il crittogramma $c$ come:
		\begin{equation*}
			c = m^{e} \mod n.
		\end{equation*}
		\item Per ottenere il messaggio $m$ dato $c$ è sufficiente calcolarlo come:
		\begin{equation*}
			m = c^{d} \mod n.
		\end{equation*}
		
	\end{itemize}
	
\end{frame}

\begin{frame}{RSA: uno sguardo alla sicurezza}
	\begin{itemize}
		\item La sicurezza di RSA è garantita grazie al problema della fattorizzazione di un numero $n$ come prodotto di due fattori $p \cdot q$.
		\item Per questo è importante scegliere due fattori primi molto grandi, tale che il modulo sia almeno $2048$ bit, meglio ancora se $3072$ bit.
		\item Nel 1999 è stato fattorizzato RSA-512 in circa $7$ mesi utilizzando centinaia di calcolatori e impiegando l'equivalente di 8400 anni di CPU.
			\begin{itemize}
				\item Nel 2009 lo stesso attacco poteva essere effettuato in 83 giorni da un solo calcolatore.
			\end{itemize}
		\item Nel 2020 il numero più grande fattorizzato ha 829 bit, impiegando l'equivalente di 2700 anni di CPU.
	\end{itemize}
\end{frame}

\begin{frame}{RSA: un'analisi sperimentale sulla sicurezza}
	\begin{itemize}
		\item Sono stati implementati tre algoritmi per la fattorizzazione:
			\begin{itemize}
				\item \emph{Wheel factorization}: fondamentalmente un brute force sul numero, cercando i divisori;
				\item \emph{Pollard's rho factorization}: di natura probabilistica, è quello più efficiente;
				\item \emph{Fermat factorization}: è più veloce se i due numeri primi sono vicini tra loro.
			\end{itemize}
		\item Sono stati fattorizzati moduli da 120 bit utilizzando l'algoritmo \emph{Pollard's rho} in poco meno di un'ora su un moderno calcolatore.
	\end{itemize}
\end{frame}

\begin{frame}{RSA: l'esponente pubblico $e$}
	\begin{itemize}
		\item L'esponente pubblico non dovrebbe essere troppo grande per velocizzare la cifratura.
		\item Con l'\emph{algoritmo delle quadrature successive}, l'operazione può essere svolta in tempo $O(\log_{2} e + hm(e))$, dove $hm(e)$ rappresenta il \emph{peso di Hamming}.
			\begin{itemize}
				\item Il peso di Hamming rappresenta il numero di simboli diversi dal simbolo $0$ dell'alfabeto utilizzato.
			\end{itemize}
		\item L'esponente pubblico, dato che non contiene alcuna informazione, viene generalmente riutilizzato per molteplici operazioni.
	\end{itemize}
\end{frame}

\begin{frame}{RSA: valori più utilizzati di $e$ con i rispettivi \emph{pesi di Hamming}}
	\begin{table}[]
	\centering
	%\caption{Valori più usati di $e$ con i rispettivi \emph{Pesi di Hamming}~\cite{lenstra:publickeys}.}
\begin{tabular}{  M{1cm} 	M{0.5cm}  S[table-format=2.2, table-space-text-post = \si{\meter}] | M{1.3cm} M{0.5cm}  S[table-format=2.2, table-space-text-post = \si{\meter}]  | M{1cm} M{0.5cm} S[table-format=2.2, table-space-text-post = \si{\meter}] } 
	%\begin{tabular}{  cccccccccc } 
	\multicolumn{3}{c|}{\emph{X.509}} & \multicolumn{3}{c|}{\emph{PGP}} & \multicolumn{3}{c}{\emph{Combinati}} \\ \hline
	\multicolumn{1}{c}{$e$}           &\multicolumn{1}{c}{$hm(e)$} 	&\multicolumn{1}{c |}{$\%$}           & \multicolumn{1}{c}{$e$}   &\multicolumn{1}{c}{$hm(e)$}           & \multicolumn{1}{c |}{$\%$}      & \multicolumn{1}{c}{$e$}     &\multicolumn{1}{c}{$hm(e)$}       & \multicolumn{1}{c}{$\%$}             \\ \hline
	65537       & 2		& 98.4921     & 65537          	& 2		& 48.8501 	& 65537        	& 2			& 95.4933        \\
	17          	& 2		& 0.7633       & 17             		& 2		& 39.5027 	& 17           	& 2			& 3.1035         \\
	3           	& 2		& 0.3772       & 41             		& 3		& 7.5727  		& 41           	& 3			& 0.4574         \\
	35          	& 3		& 0.1410       & 19             		& 3		& 2.4774  		& 3            	& 2			& 0.3578         \\
	5           	& 2		& 0.1176       & 257            	& 2		& 0.3872  		& 19           	& 3			& 0.1506         \\
	7           	& 3		& 0.0631       & 23             		& 4		& 0.2212  		& 35           	& 3			& 0.1339         \\
	11          	& 3		& 0.0220       & 11             		& 3		& 0.1755  		& 5            	& 2			& 0.1111         \\
	47          	& 5		& 0.0101       & 3              		& 2		& 0.0565  		& 7            	& 3			& 0.0596         \\
	13          	& 3		& 0.0042       & 21             		& 3		& 0.0512  		& 11           	& 3			& 0.0313         \\
	65535       & 16		& 0.0011       & $2^{127} + 3$  	& 3		& 0.0248  		& 257          	& 2			& 0.0241         \\
	altri       	& -		& 0.0083       & altri          		& -		& 0.6807  		& altri        	& -			& 0.0774        
	\end{tabular}
	%\label{tabella:valorie}
	\end{table}

\end{frame}

\begin{frame}{RSA: gli schemi di padding}
	\begin{itemize}
		\item Prima di essere cifrato mediante RSA, ogni messaggio viene modificato con gli schemi di padding.
		\item Gli schemi di padding sono importanti in crittografia:
			\begin{itemize}
				\item aggiungono una componente di casualità;
				\item non rendono possibile un recupero anche parziale del messaggio, fissandone univocamente la lunghezza.
			\end{itemize}
		\item Due degli schemi più utilizzati sono \emph{PKCS1 v1.5} ed \emph{OAEP}.
	\end{itemize}
\end{frame}

\begin{frame}{RSA: malleabilità senza il padding}
	\begin{itemize}
		\item Il padding aiuta ad evitare che RSA sia \emph{malleabile}.
		%\item RSA senza l'utilizzo del padding è \emph{malleabile}.
			\begin{itemize}
				\item Ad esempio, se un attaccante conosce $c = m^{e} \mod n$, che non utilizza il padding, può sostituire $c' = c \cdot 2^{e} \mod n$.
				\item Quando $c'$ verrà decifrato, si otterrà $2m$ invece che l'originario $m$.
			\end{itemize}
		\item Con il padding questa modifica molto semplice non è più possibile.
	\end{itemize}
\end{frame}

\begin{frame}{RSA: generazione errata della chiave}
	\begin{itemize}
		\item L'esponente $e$ deve essere scelto coprimo con $\phi(n)$.
		\item In una pre-release di Windows 10, non veniva effettuato il controllo che $gcd(e,\phi(n)) = 1$ nel momento in cui veniva scelto l'esponente pubblico.
		\item Il corretto funzionamento di RSA è compromesso e la decifrazione non è più possibile.
	\end{itemize}
\end{frame}

\begin{frame}{RSA: la probabilità di scegliere l'esponente pubblico errato}
	\begin{itemize}
		\item Ma quanto spesso questo problema si verifica nella pratica?
		\item Per $e = 65537$, la probabilità $P$ che $e | (p - 1)$ \emph{oppure} $e | (q - 1)$ è data da
			\begin{equation*}
				P < \frac{1}{32000}
			\end{equation*}
			\begin{itemize}
				\item Il caso $e^{i} | (p - 1) \cdot (q - 1)$ con $i > 2$ non verrà trattato.
			\end{itemize}
		\item Windows 10 è utilizzato da oltre un miliardo di dispositivi.
			\begin{itemize}
				\item Più di 30000 utenti coinvolti.
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{RSA: il recupero dei messaggi erroneamente cifrati}
	\begin{itemize}
		\item Se la chiave viene generata in modo errato ad ogni crittogramma potrebbero corrispondere $e$ messaggi che lo generino.
		\item E se i messaggi perduti sono importanti?
		\item Il recupero dei messaggi è esponenziale nella dimensione di $e$.
			\begin{itemize}
				\item Per fortuna, $e$ viene generalmente scelto basso.
				\item Per $e = 65537$ il recupero dei messaggi con un moderno calcolatore avviene in circa 30 secondi.
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{RSA: scartare i messaggi durante il recupero}
	\begin{itemize}
		\item Come si possono scartare i messaggi automaticamente?
		\item Analizzando il contesto.
		\item Analizzando i messaggi che rispettano le caratteristiche degli schemi di padding:
			\begin{itemize}
				\item con \emph{OAEP}, ci si aspetta solo un risultato (il messaggio originario);
				\item con \emph{PKCS1 v1.5} ci si aspetta almeno un falso positivo.
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{RSA: esponente pubblico corto}
	\begin{itemize}
		\item Un bug imponeva $e = 1$.
		\item Si deve prestare attenzione che intervenga la riduzione in modulo.
		\item In generale moduli corti possono facilitare gli attacchi basati sui reticoli.
	\end{itemize}
\end{frame}

\begin{frame}{RSA: moduli ripetuti}
	\begin{itemize}
		\item È comune che uno stesso modulo $n$ sia condiviso tra più host.
			\begin{itemize}
				\item Il 4\% dei moduli usati in HTTPS risulta condiviso tra più host.
				\item Il 60\% delle chiavi SSH e il 65\% di quelle usate per IPv4 risultano condivise.
				\item Non è una vulnerabilità se gli host non sono correlati.
			\end{itemize}
		\item Molti router e dispositivi della stessa linea di un produttore condividono lo stesso modulo: si possono decifrare i testi a vicenda.
		\item A causa di problemi con il PRNG e con i seed iniziali molte chiavi sono risultate uguali.
	\end{itemize}
\end{frame}


\begin{frame}{RSA: un fattore in comune}
	\begin{itemize}
		\item Se un primo è condiviso tra due moduli $n_{1}$ e $n_{2}$ è possibile trovare facilmente l'altro primo come $gcd(n_{1}, n_{2})$.
		\item Esistono dataset pubblici contenenti moduli RSA, per verificare se uno dei due primi è condiviso.
	\end{itemize}
\end{frame}


\begin{frame}{RSA: vulnerabilità DROWN}
	\begin{itemize}
		\item Nella sua prima versione sfruttava il semplice schema di padding \emph{PKCS1 v1.5}.
		\item Si può effettuare se il server manda un errore se il padding è errato.
		\item Per questo attacco sono necessarie milioni di query.
			\begin{itemize}
				\item Sfruttando il messaggio di errore un attaccante può restringere i possibili valori assunti da $m$.
			\end{itemize}
		\item Si stima che nel 2016 il 33\% dei siti HTTPS fossero vulnerabili a questo attacco.
	\end{itemize}
\end{frame}

\begin{frame}{RSA: conclusioni}
	\begin{itemize}
		\item Al giorno d'oggi esistono alternative migliori per lo scambio della chiave.
		\item RSA non è sicuro per utilizzi post-quantistici.
			\begin{itemize}
				\item L'\emph{algoritmo di Shor} sui computer quantistici permette di calcolare la fattorizzazione in tempo polinomiale probabilistico.
			\end{itemize}
		\item Ridurre l'utilizzo di RSA è difficile per ragioni di retrocompatibilità.
			\begin{itemize}
				\item Di TLS v1.3 è stata ritardata l'uscita perché al suo interno ha eliminato lo scambio di chiavi basato su RSA.
			\end{itemize}
	\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Diffie-Hellman}
\begin{frame}
	\sectionpage
	\centering
\end{frame}

\begin{frame}{Diffie-Hellman: la teoria dietro al protocollo}
	\begin{itemize}
		\item 
	\end{itemize}
\end{frame}

\begin{frame}
	\begin{itemize}
		\item 
	\end{itemize}
\end{frame}


\begin{frame}{}
	\begin{itemize}
		\item 
	\end{itemize}
\end{frame}


\begin{frame}{}
	\begin{itemize}
		\item 
	\end{itemize}
\end{frame}
















\end{document}
